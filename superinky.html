<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SuperInky</title>
  <style>
    html, body { margin: 0; padding: 0; background: transparent; overflow: hidden; }
    #game { display: block; margin: 0 auto; background: #87CEEB; }
  </style>
</head>
<body>
  <canvas id="game" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // ----- Preload Hero Frames -----
    const frames = ['superinky_fly1.PNG','superinky_fly2.PNG'].map(src => {
      const img = new Image(); img.src = src; return img;
    });
    let frameIndex = 0;

    // ----- Hero properties -----
    const heroWidth = 64;
    const heroHeight = 64;
    let heroX = canvas.width / 4;
    let heroY = canvas.height / 2;
    let velocity = 0;

    // ----- Physics & Control -----
    const gravity = 0.05;
    const jump = -3;

    // ----- Obstacle (skyscraper) setup -----
    const skyscraperImg = new Image();
    skyscraperImg.src = 'skyscraper.PNG';
    const OBSTACLE_WIDTH   = 80;
    const OBSTACLE_GAP     = 360;
    const OBSTACLE_SPACING = 400;
    const skyscraperSpeed  = 1;
    const obstacles = [];

    function spawnObstacle(x) {
      const topHeight = 50 + Math.random() * (canvas.height - OBSTACLE_GAP - 100);
      obstacles.push({ x, topHeight, bottomY: topHeight + OBSTACLE_GAP });
    }

    // Seed initial obstacles
    for (let x = canvas.width; x < canvas.width + OBSTACLE_SPACING * 3; x += OBSTACLE_SPACING) {
      spawnObstacle(x);
    }

    // ----- Update function -----
    function update() {
      // Hero physics
      velocity += gravity;
      heroY += velocity;
      if (heroY < 0) heroY = 0;
      if (heroY + heroHeight > canvas.height) {
        heroY = canvas.height - heroHeight;
        velocity = 0;
      }

      // Move obstacles
      obstacles.forEach(obs => obs.x -= skyscraperSpeed);
      const last = obstacles[obstacles.length - 1];
      if (last.x < canvas.width - OBSTACLE_SPACING) spawnObstacle(canvas.width);
      if (obstacles[0].x + OBSTACLE_WIDTH < 0) obstacles.shift();
    }

    // ----- Draw function -----
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw skyscrapers
      obstacles.forEach(obs => {
        // Top building (upside down)
        ctx.save();
        ctx.translate(obs.x, obs.topHeight);
        ctx.scale(1, -1);
        ctx.drawImage(
          skyscraperImg,
          0, 0, skyscraperImg.width, obs.topHeight,
          0, 0, OBSTACLE_WIDTH, obs.topHeight
        );
        ctx.restore();
        // Bottom building
        const bottomHeight = canvas.height - obs.bottomY;
        ctx.drawImage(
          skyscraperImg,
          0, skyscraperImg.height - bottomHeight,
          skyscraperImg.width, bottomHeight,
          obs.x, obs.bottomY, OBSTACLE_WIDTH, bottomHeight
        );
      });

      // Draw hero frame
      const heroImg = frames[frameIndex];
      ctx.drawImage(heroImg, heroX, heroY, heroWidth, heroHeight);
    }

    // ----- Game loop -----
    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    // ----- Input handler -----
    canvas.addEventListener('click', () => {
      velocity = jump;
      frameIndex = 1;
      setTimeout(() => { frameIndex = 0; }, 100);
    });
  </script>
</body>
</html>
